---
alwaysApply: true
---
Cursor Rules – Full-Stack Go + React (TS)

General Guidelines

Think in English, but always reply in English.

Follow the user’s requirements exactly as stated.

Before implementing, write a detailed step-by-step pseudocode plan.

When using APIs or language features, always consult the latest official documentation first.

Deliver code that is up-to-date, bug-free, secure, performant, and fully functional.

Favor readability over raw performance.

Avoid hard-coding by extracting constants or configuration.

Implement every requested feature completely—no TODOs, placeholders, or missing parts.

Perform a final check to prevent runtime errors.

Include all necessary packages and use clear names.

Keep prose concise—minimize narrative beyond what is necessary.
--------------------------------------------------------------------------------

Code Quality

Prioritize readability.

Eliminate duplication (DRY) and honor the Single Responsibility Principle.

Extract shared logic into reusable components, packages, or hooks.

Replace hard-coded values with constants or environment variables.

Centralize error handling (e.g., an error-handling middleware).

Logging: Use a structured logger like uber-go/zap and propagate trace-id via context.
--------------------------------------------------------------------------------

Code Style

Go: Follow the standard Go style using gofmt.

React/TS: Apply ESLint + Prettier rules (2-space indent).

Limit lines to ≤ 80 columns.

In comments, explain "why" the code is written, not "what" it does.

Ensure all required package imports and clear component/function names.
--------------------------------------------------------------------------------

Documentation

Add godoc comments to every exported function/type and TSDoc to every public API.

Maintain README.md (setup, run, deploy, FAQ) and CHANGELOG.md.

Document complex domain logic in docs/architecture/ with diagrams (ADR, PlantUML, etc.).
--------------------------------------------------------------------------------

Testing

Aim for a minimum of 80% unit test coverage (Go's built-in testing package / Jest + React Testing Library).

Write integration tests using Testcontainers (for PostgreSQL 16).

Optionally, write E2E tests with Playwright or Cypress.
--------------------------------------------------------------------------------

Security

Always validate user input.

Use parameterized queries to prevent SQL Injection and escape output to prevent XSS.

Store secrets in environment variables or a secret management tool like Vault.

Regularly scan dependencies using tools like npm audit and govulncheck.
--------------------------------------------------------------------------------

Performance

Optimize queries.

Actively use lazy loading and pagination.

Run heavy tasks asynchronously using goroutines.

Implement caching with Redis or an in-memory cache library like go-cache.
--------------------------------------------------------------------------------

Database (PostgreSQL 16)

Use golang-migrate/migrate for database schema version control (db/migrations directory).

Use EXPLAIN ANALYZE and pg_stat_statements to analyze and diagnose query performance.
--------------------------------------------------------------------------------

Version Control (Git Workflow)

Follow Conventional Commits and Semantic Versioning.

Develop on feature branches (e.g., feat/*), then create a Pull Request to main for code review and merging.

Keep the main branch perpetually deployable.
--------------------------------------------------------------------------------

CI/CD

GitHub Actions pipeline: Lint (golangci-lint) → Test → Build → Build Docker Image → Deploy.

Scan Docker images for vulnerabilities using Trivy.
--------------------------------------------------------------------------------

Project Structure

Go (Backend)

/
├── cmd/app/          # Application entry point (main.go)
├── internal/
│   ├── handler/      # HTTP handlers (controllers)
│   ├── service/      # Business logic
│   ├── repository/   # Database interactions
│   └── domain/       # Core domain models and types
├── configs/          # Configuration files (e.g., config.yaml)
├── go.mod            # Go module file
└── go.sum
React (TypeScript) + Vite (Frontend)

/webUI
└── src/
    ├── api/          # API call functions (axios, fetch)
    ├── assets/       # Static files (images, fonts)
    ├── components/   # Reusable UI components
    ├── hooks/        # Custom React hooks (e.g., useApi)
    ├── pages/        # Route-level page components
    ├── router/       # React Router configuration
    ├── store/        # Global state management (Zustand, Redux Toolkit)
    ├── types/        # TypeScript type definitions
    ├── utils/        # Utility functions
    └── main.tsx      # App entry point
    
--------------------------------------------------------------------------------
Naming Conventions

Directories: kebab-case (frontend), snake_case or lowercase (backend)

React Components: PascalCase.tsx

Custom Hooks: useSomething.ts

Go Constants: PascalCase (Exported), camelCase (Internal)

CSS (BEM): block__element--modifier
--------------------------------------------------------------------------------
Key CLI Commands

Bash

Bash
# React + TypeScript (Vite)
npm create vite@latest my-react-app -- --template react-ts
cd my-react-app && npm i && npm run dev

# Go
go run ./cmd/app                  # Run the application
go test -v ./...                  # Run all tests (verbose output)
go build -o build/app ./cmd/app   # Build the application binaryCursor Rules – Full-Stack Go + React (TS)